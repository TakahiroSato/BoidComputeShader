// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct BoidState
{
    float3 orgPosition;
    float3 position;
    float3 forward;
    float3 color;
    float3 angle;
    float size;
    float rad;
};

struct AudioState
{
    float spectram;
    float frequencey;
};

RWStructuredBuffer<BoidState> boidBuffer; // C#からデータを受け取る
RWStructuredBuffer<AudioState> audioBuffer;

uint numBoids;
uint fftResolution;
float deltaTime;
half separationWeight;
half alignmentWeight;
half targetWeight;
half moveSpeed;
float3 targetPosition;

float3 pos;

float3 normalizeSafe(float3 v)
{
    return length(v) > 0 ? normalize(v) : 0;
}

[numthreads(32,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint boidIndex = id.x;
    BoidState boidSelf = boidBuffer[boidIndex];

    int idx = fftResolution - (boidIndex / (numBoids / fftResolution));
    AudioState audio = audioBuffer[idx];

    float volume;
    for (uint i = 0; i < fftResolution; ++i)
    {
        volume += audioBuffer[i].spectram;
    }

    int pow = 1 + (boidIndex / fftResolution) * 0.11;

    boidSelf.position -= (boidSelf.position - boidSelf.orgPosition) / (pow);

    float3 pos = boidSelf.orgPosition;

    float factor = (audio.spectram * volume);

    double rad = 0;
    boidSelf.position.x += (pos.x * cos(rad) + pos.y * sin(rad)) * factor;
    boidSelf.position.y += (pos.x * -1 * sin(rad) + pos.y * cos(rad)) * factor;

    boidSelf.position *= 1 + (volume / 250);

    pos = boidSelf.position;
    boidSelf.color = float3(pos.x * boidIndex / numBoids, pos.y, audio.spectram * boidIndex / numBoids) * audio.spectram * volume / 10;

    boidBuffer[boidIndex] = boidSelf;
}
